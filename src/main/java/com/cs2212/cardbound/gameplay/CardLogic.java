package com.cs2212.cardbound.gameplay;

import com.cs2212.cardbound.MainStage;
import com.cs2212.cardbound.system.Gameplay;
import javafx.scene.image.Image;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.CharBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Random;

/**
 * This class deals with all the logic required to get cards into the game, along with calculating damage between any
 * two cards
 * @author Abhinav Bhati
 * @version 1.0
 * @since 3/18/2024
 */
public class CardLogic {

    // End ranges of card pools
    private static final int DMG_POOL = 8; // End of dmg pool, exclusive
    private static final int MOD_POOL = 15;// End of mod pool, exclusive

    /**
     * Method that will create a list of integers to decide on which card pool is drawn from
     * 0 represents the damage pool, 1 represents the modifier pool
     * @return a list of 0's or 1's that is 4 numbers long
     */

    public static int[] generateCardPools(){

        Random random = new Random(); // Setting up to use the random function

        int[] cardPoolChoices = {0,0,0,0}; // Creating a list, there must always be one damage card to start

        for (int i = 1; i < 4; i++){ // Adds 3 choices, 1 or 0
            cardPoolChoices[i] = random.nextInt(2);
        }

        return cardPoolChoices;
    }

    /**
     *  Creates a list of integers that represent indices in the card pool CSV
     * @param cardPoolChoices This list of integers will be generated by the generateCardPools function
     * @return The list of indices
     */

    public static int[] generateCardIndexList(int[] cardPoolChoices){

        Random random = new Random(); // Setting up to use the random function

        int[] cardIndex = {0,0,0,0}; // Creating an empty list

        for (int i = 0; i < 4; i++){ // Adds 4 choices, 1 or 0

            if (cardPoolChoices[i] == 0) { cardIndex[i] = random.nextInt(1, DMG_POOL); } // The dmg pool

            else{ cardIndex[i] = random.nextInt(DMG_POOL, MOD_POOL); } // The modifier pool

        }
        return cardIndex;
    }


    /**
     * This method will read the card's data from the CSV and create a list that we can use to build the cards
     * @param indexList The indexList from the generateIndexList function
     * @return An array of lists that holds all 4 cards, and each of their individual data
     */
    public static String[][] cardDataReader (int[] indexList) {

        String[][] cardDataList = new String[indexList.length][]; // Initializing an array to hold all 4 card's data

//        BufferedReader reader = new BufferedReader(new FileReader(MainStage.class.getResource("CardData.CSV").toExternalForm()));

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(MainStage.class.getResourceAsStream("CardData.CSV"))))) {

            // Initialize some numbers to help with incrementing and positioning in the loops
            String curLine;
            int lnNum = 1;

            // This loop will add the card associated with the current line if it is in the list of indexes chosen
            while ((curLine = reader.readLine()) != null) {
                for (int i = 0; i < contains(indexList, lnNum); i++){ // The for loop ensures that duplicate cards will be added
                    List<Integer> indices = indexOf(indexList, lnNum);
                    String[] curLineData = curLine.split(",");
                    for (int j = 0; j < curLineData.length; j++)
                        curLineData[j] = curLineData[j].trim();
                    cardDataList[indices.get(i)] = curLineData;
                }

                lnNum++; // Go next line
            }
        }

        catch (IOException e) {
            System.out.println("");
        }

        return cardDataList;
    }

    /**
     *  This is a helper method to check whether a number is inside a list, and how many.
     * @param list Takes in a list of integers
     * @param checkVal The value we are checking for
     * @return The number of occurrences that the checkVal was found in the list
     */

    private static int contains(int[] list, int checkVal) {
        int counter = 0; // To determine how many times it is in the list
        for (int num : list) { if (num == checkVal) { counter++;} } // If it is inside the list

        return counter; // Return num occurrences
    }

    /**
     * A helper method to return the indices of where an element is in the list
     * @param indexList Takes a list of integers
     * @param value The value that is being searched for
     * @return the positions of the value in the list
     */
    public static List<Integer> indexOf(int[] indexList, int value) {
        List<Integer> indices = new ArrayList<>();
        for (int i = 0; i < indexList.length; i++) {
            if (indexList[i] == value) {
                indices.add(i); // Add the index to the list if the value is found
            }
        }
        return indices; // Return the list of indices
    }

    /**
     * Load data for new card from cardData array
     * @param card the card to be initialized
     * @param cardData the card data
     * @param locationX location of the card on the X-axis
     * @param locationY location of the card on the Y-axis
     */
    public static void buildCard(Card card, String[] cardData, int locationX, int locationY) {
        String cardDesc = cardData[1];
        if (cardData[2].equalsIgnoreCase("attack")) {
            card.setAttackDmg(Integer.parseInt(cardData[4]) * Gameplay.getCardMultiplier());
            card.setNumAttacks(Integer.parseInt(cardData[5]));

            char[] initialChar = {'?'};
            CharSequence initialSequence = CharBuffer.wrap(initialChar);
            CharSequence replacementSequence = CharBuffer.wrap(String.valueOf(card.getAttackDamage()).toCharArray());

            cardDesc = cardDesc.replace(initialSequence, replacementSequence);
        } else {
            card.setCardEffect(cardData[4]);
            card.setNumAttacksAffected(Integer.parseInt(cardData[5]));
        }

        card.setTitle(cardData[0]);
        card.setDescription(cardDesc);
        card.setType(cardData[2]);
        card.setImage(new Image(Objects.requireNonNull(MainStage.class.getResourceAsStream("sprites/card/" + cardData[3]))));
        card.getImageView().setPreserveRatio(false);
        card.setLayoutX(locationX);
        card.setLayoutY(locationY);
    }

    /**
     * This method calculates the damage between the interaction of two cards, in the paramater cardA will always be a
     * damage card whereas cardB can be either
     * @param cardA Must be damage card
     * @param cardB Can be either damage or modifier
     * @return the total damage calculated between the interaction of two cards
     */
    public static int calculateTotalDamage (Card cardA , Card cardB) { // FIXME: With current implementation cardB must always be the modifier card

        // CARD A is DAMAGE CARD, CARD B is either or
        // store cardB's type, so we can perform operations based on it's value
        String cardBType = cardB.getType().getText();

        // Ensure both cards are not modifiers
        String cardAType = cardA.getType().getText();
        if (cardAType.equalsIgnoreCase("modifier")){ return 0; } // Does no damage if both cards are modifiers

        int totalDamage = 0; // The final value that will be returned

        // Special Card Interactions, any cards that require a tweak to the calculation algorithm

        // Gatling Gun, adjusting attack value
        if (cardA.getTitle().getText().equals("Gatling Gun")) { cardA.setAttackDmg(cardA.getAttackDamage()/4);}
        if (cardB.getTitle().getText().equals("Gatling Gun")) { cardB.setAttackDmg(cardB.getAttackDamage()/4); }

        ArrayList<Integer> attackQueueA = new ArrayList<>(); //initialize an array to store attacks/damage values

        int numAttacks = cardA.getNumAttacks();
        // The initial attack queue before modification or summation is the damage card
        for (int i = 0; i < numAttacks; i++) {attackQueueA.add(cardA.getAttackDamage());}

        // For when CardB is a modifier card
        if (cardBType.equalsIgnoreCase("modifier")) {

            // Getting the necessary variables
            String modifierEffect = cardB.getCardEffect();
            int numAttacksAffected = cardB.getNumAttacksAffected();

            // initialize queues to handle modifier math
            ArrayList<String> operatorQueue = new ArrayList<>();
            ArrayList<Float> operandQueue = new ArrayList<>();

            String currentNumber = "";
            // This loop will take the string data and transfer it to the queues so that we can calculate the modified values
            for (int j = 0; j < modifierEffect.length(); j++) {
                // Setting variables to determine where in the equation we are
                String currentCharacter = String.valueOf(modifierEffect.charAt(j));

                // For when we encounter an operator, add to the operator queue
                if (currentCharacter.equals("*") || currentCharacter.equals("+") || currentCharacter.equals("%")) {
                    operatorQueue.add((currentCharacter)); // Adds the current character to the operator queue
                    // Adds the current number to the operand queue as we have reached an operator
                    operandQueue.add(Float.parseFloat(currentNumber));
                    currentNumber = ""; // Readies the variable for building the next number
                }

                // When we encounter "x", it is a direct reference to the damage card's (cardA) attack value
                else if (currentCharacter.equals("x")) {
                    //operandQueue.add((float) cardA.getAttackDamage());
                    currentNumber = currentNumber + cardA.getAttackDamage();
                }

                // Concatenate to currentNumber as it must be a number if it's not an operator or "x"
                else {
                    currentNumber = currentNumber + currentCharacter;
                }
            }
            operandQueue.add(Float.parseFloat(currentNumber)); // To add whatever number is last

            float currentTotal = 0; // To sum the calculations from left to right

            // Create the modified attack value
            for (int i = 0; i < operatorQueue.size(); i++) { // The math logic will be built around the operators

                if (operatorQueue.get(i).equals("+")) { // Creating addition
                    if (i == 0) { // For the first operator
                        currentTotal = operandQueue.get(i) + operandQueue.get(i + 1);
                    } else { // For further operators
                        currentTotal = currentTotal + operandQueue.get(i + 1);
                    }
                } else if (operatorQueue.get(i).equals("*")) { // Creating multiplication
                    if (i == 0) { // For the first operator
                        currentTotal = operandQueue.get(i) * operandQueue.get(i + 1);
                    } else { // For further operators
                        currentTotal = currentTotal * operandQueue.get(i + 1);
                    }
                }
                else if (operatorQueue.get(i).equals("%")) { // Creating multiplication
                    if (i == 0) { // For the first operator
                        // Modulo on two floats is not allowed, so cast them accordingly
                        int intValue1 = operandQueue.get(i).intValue();
                        int intValue2 = operandQueue.get(i + 1).intValue();
                        currentTotal = (float) (intValue1 % intValue2);
                    } else { // For further operators
                        int intValue1 = (int)currentTotal;
                        int intValue2 = operandQueue.get(i + 1).intValue();
                        currentTotal = (float) (intValue1 % intValue2);
                    }

                }
            }

            // if numOfCardsAffected is infinite, set numAttacksAffected equal to numAttacks of cardA
            if (numAttacksAffected == -1) { numAttacksAffected = cardA.getNumAttacks(); }

            // determines how many times to apply/add the modified value to the attack queue
            for (int i = 0; i < numAttacksAffected; i++) {
                if (i >= numAttacks) { break; } // For when there are more attacks effected than attacks, leaves the loop

                attackQueueA.set(i, (int)currentTotal); // Sets the attack queue value to the modified value
            }

            // Calculate the total damage with modified values
            for (int i = 0; i < attackQueueA.size(); i++){
                totalDamage = totalDamage + attackQueueA.get(i); // Sums the current value with the subtotal
            }
        }
        // For when CardB is a damage card
        else if (cardBType.equalsIgnoreCase("attack")) {
            int cardACalcDmg = cardA.getAttackDamage() * cardA.getNumAttacks();
            int cardBCalcDmg = cardB.getAttackDamage() * cardB.getNumAttacks();
            totalDamage = cardACalcDmg + cardBCalcDmg;

        } else { // In the case it's not reading properly
            System.out.println("ERROR: Card type " + cardBType + " Invalid");
        }

        // Special Card Interactions

        // Gatling Gun, resetting attack value
        if (cardA.getTitle().getText().equals("Gatling Gun")) { cardA.setAttackDmg(cardA.getAttackDamage()*4);}
        if (cardB.getTitle().getText().equals("Gatling Gun")) { cardB.setAttackDmg(cardB.getAttackDamage()*4); }


        return totalDamage; // Return the total damage
    }
}
